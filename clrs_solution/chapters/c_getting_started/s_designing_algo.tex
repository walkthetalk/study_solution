\startsection[
  title={Designing algorithms},
]

\startEXERCISE
參照圖 2.4，對數列 $A=\langle 3,41,52,26,38,57,9,49\rangle$ 進行歸並排序。
\stopEXERCISE
\startANSWER
\externalfigure[output/e2_3_1-1]
\stopANSWER

\startEXERCISE
\ALGO{MERGE-SORT} 例程中，
第一行在測試時用的是“\CLRSCODE{if p \ge r}” 而不是“\CLRSCODE{if p\ne r}”。
在調用 \ALGO{MERGE-SORT} 時，
如果 $p>r$ 則子數列 $A[p:r]$ 爲空。
只要第一次調用 \ALGO{MMERGE-SORT(A,1,n)} 時 $n\ge 1$，
測試“\CLRSCODE{if p\ne r}”就能保證遞歸調用時不會出現 $p>r$ 的情況。
\stopEXERCISE
\startANSWER
第一次調用時 $n\ge 1$ 即 $p\le r$，滿足要求；
如果測試條件為 $p\ne r$，
則 $p\le q$ 且 $q+1\le r$，
即滿足遞歸調用時 $p\le r$；
因此只要保證第一次調用時 $n\ge 1$，
測試 $p\ne r$ 就能保證遞歸調用時不會出現 $p>r$ 的情況。
\stopANSWER

\startEXERCISE
分析例程 \ALGO{MERGE-SORT} 中第 12~18 行 \CLRSCODE{while} 循环中的循環不變性。
根據這個性質，與 \CLRSCODE{while} 循環中第 20~23 行和 24~27 行一起，
證明例程 \ALGO{MERGE-SORT} 的正確性。
\stopEXERCISE
\startANSWER
\TODO{略。}
\stopANSWER

\startEXERCISE
用數學歸納法證明：如果 $n\ge 2$ 是 $2$ 的冪，
則下式的解為 $T(n)=n\lg n$。
\startformula
T(n)=\startmathcases
\NC 2 \NC \text{若 $n=2$，}\NR
\NC 2 T(n/2) + n \NC \text{若 $n>2$。} \NR
\stopmathcases
\stopformula
\stopEXERCISE

\startANSWER
\startigBase[n]
\item $n=2$ 時， $T(n)=2=n\lg n$，成立；
\item 如果 \m{T(n) = n \lg(n)}，那麼：
\startformula\startalign
\NC T(2n) \NC = 2n \lg(2n) \NR
\NC       \NC = 2n (\lg(n) + 1) \NR
\NC	      \NC = 2n \lg(n) + 2n \NR
\NC	      \NC = 2T(n) + 2n \NR
\stopalign\stopformula
\item 由 1）、 2）归纳可知，問題得證。
\stopigBase
\stopANSWER

\startEXERCISE
以遞迴方式進行插入排序：
要對 $A[1:n]$ 排序，
可以先對子數列 $A[1:n-1]$ 排序，
然後將 $A[n]$ 插入子數列 $A[1:n-1]$ 中。
試給出此算法的僞碼。
並分析最壞情況下的算法是如何運行的。
\stopEXERCISE
\startANSWER
\CLRSH{INSERTION_SORT_R(A, n)}
\startCLRSCODE
if n < 2
	return
\ALGO{INSERTION_SORT_R(A, n-1)}
key = A[n]
i = n - 1
while i \ge 0 and A[i] > key
	A[i+1] = A[i]
	i = i - 1
A[i + 1] = key
\stopCLRSCODE

\startformula
T(n) = \startmathcases
\NC 0 \NC \text{若 $n = 1$，} \NR
\NC T(n-1) + C(n-1)	\NC \text{否則。} \NR
\stopmathcases
\stopformula

初始數列爲逆序的情況下，需要移動元素最多，每次遞迴都需要遍歷所有元素：

$T(n) = 1 + 2 + 3 + ... + (n-1) = \Theta(n^2)$
\stopANSWER

\startEXERCISE[exercise:bin_search]
回顧\refexercise{linear_earch} 中的搜索問題，我們發現：
如果待搜索的子數列已經排好序，
則搜索算法可以檢查子數列的中間數值，而不是檢查 $v$，
在下一步搜索時可以直接跳過子數列中的一半數據。
二分查找算法就是重複這個過程，
每次都可以使得帶搜索的子數列減半。
試寫出二分查找算法的僞碼，遍歷、遞迴均可。
並證明在最壞情況下，此算法的運行時間為 $\Theta(\lg n)$。
\stopEXERCISE
\startANSWER
\CLRSH{BINARY-SEARCH(A, v)}
\startCLRSCODE
low = 1
high = A.length
while low \le high
	m = (low + high) / 2
	if A[m] == v
		return m
	if A[m] < v
		low = m + 1
	else
		high = m - 1
return NIL
\stopCLRSCODE

\startformula
T(n) = T(n/2) + c = \Theta(\lg n)
\stopformula
\stopANSWER

%e2.3-7
\startEXERCISE
在\insection[insersion_sort] 的例程 \ALGO{INSERTION-SORT} 中，
第 5~7 行的 \CLRSCODE{while} 循環以綫性搜索的方式，
後向掃描已排好序的子數列 $A[1:j-1]$。
如果用二分查找（\refexercise{bin_search}）代替綫性查找，該怎麽做？
這能將最壞情況的運行時間提升到 $\Theta(n\lg n)$ 嗎？
\stopEXERCISE
\startANSWER
不行，二分查找只可能減少比較的次數，而無法減少數據搬移的次數。
\stopANSWER

\startEXERCISE
設計一個最壞運行時間爲 $\Theta(n\lg n)$ 的算法，
用來在集合 $S$ 中查找是否有兩個數的和正好是 $x$。
\stopEXERCISE

\startANSWER
\CLRSH{PAIR-EXISTS(S, x)}
\startCLRSCODE
A = \ALGO{MERGE-SORT(S)}

for i=S.length downto 1
	if \ALGO{BINARY-SEARCH(A[1:i-1], x - S[i])} \ne NIL
		return true

return false
\stopCLRSCODE
\stopANSWER

\stopsection
