\startcomponent c_sorting_in_linear_time

\startchapter[
%reference=,	%The reference key for cross-referencing (with \at, \in etc.)
title={Sorting in Linear Time},	%The title of the section
%list=,	%The title to show in the table of contents, if different
%bookmark=,	%The title to show in the PDF bookmarks, if different
%marking=,	%The title to use in the section marking, if different
%label=	 ?,
]

\startsection[
  title={Lower bounds for sorting},
  reference=section:lower_bound_sorting,
]

\startEXERCISE
在一棵比較排序算法的決策樹中，一個葉節點可能的最小深度是多少？
\stopEXERCISE

\startANSWER
最小深度是 \m{\Theta(n)}，更準確的來說是 \m{n-1}。
要檢查一個數組是不是已經排好序，至少要比較 \m{n-1} 次。
插入排序就是如此。
\stopANSWER

\startEXERCISE[exercise:bound_of_lgnfrac]
不用 Stirling 近似公式，給出 \m{\lg(n!)} 的漸進緊確界。
利用 A.2 節中介紹的技術來求累加和 \m{\sum_{k=1}^n\lg{k}}。
\stopEXERCISE

\startANSWER
先來證明解爲 \m{O(n\lg{n})}：
\startformula
\sum_{k=1}^n\lg{k} \le \sum_{k=1}^n\lg{n} = n\lg{n} = O(n\lg{n})
\stopformula

再來證明解爲 \m{\Omega(n\lg{n})}：
\startformula\startmathalignment
\NC \sum_{k=1}^n\lg{k}
   \NC= \sum_{k=1}^{\lfloor n/2 \rfloor}\lg{k} +
	\sum_{k=\lfloor n/2 \rfloor + 1}^n\lg{k} \NR
\NC\NC\ge \sum_{k=\lfloor n/2 \rfloor + 1}^n\lg{k} \NR
\NC\NC\ge \sum_{k=n/2}^n\lg{k} \NR
\NC\NC\ge \sum_{k=n/2}^n\lg{n/2} \NR
\NC\NC\ge (n/2)\lg(n/2) \NR
\NC\NC= \frac{1}{2}n\lg{n} - \frac{1}{2}n \NR
\NC\NC= \Omega(n\lg{n}) \NR
\stopmathalignment\stopformula
\stopANSWER

\startEXERCISE
證明：對於 \m{n!} 種長度爲 \m{n} 的輸入中，至少有一半不能在線性運行時間內進行比較排序。
如果只要求對 \m{1/n} 的輸入達到線性時間呢？ \m{1/2^n} 呢？
\stopEXERCISE

\startANSWER
如果能在線性時間內排序，則路徑在決策樹上的高度要小於等於 \m{n}，
而高度爲 \m{n} 的二叉樹最多有 \m{2^n} 個葉子節點，因此：
\startformula
\frac{n!}{2} \le 2^n
\stopformula
只有 \m{n} 很小時上式才能成立。

對於 \m{\frac{n!}{n} \le 2^n} 和 \m{\frac{n!}{2^n}\le 2^n \Leftrightarrow n! \le 4^n}，
都只有當 \m{n} 很小時才成立。
\stopANSWER

\startEXERCISE
假設現有一個包含 \m{n} 個元素的待排序序列，
該序列由 \m{n/k} 個子序列組成，
每個子序列包含 \m{k} 個元素。
一個給定子序列中的任一元素都小於其後繼子序列中的所有元素，
且大於其前驅子序列中的所有元素。
因此，對於這個長度爲 \m{n} 的序列的排序轉化爲對 \m{n/k} 個子序列中的 \m{k} 個元素的排序。
試證明：這個排序問題中所需比較次數的下界是 \m{\Omega(n\lg{k})}。
（\hint 單地將每個子序列的下界進行合並是不嚴謹的。）
\stopEXERCISE

\startANSWER
共有 \m{n/k} 個子序列，每個都有 \m{k!} 種排序結果。
這樣共有 \m{(k!)^{n/k}} 種輸出。則：
\startformula
(k!)^{n/k}\le 2^h
\stopformula

兩邊同取對數，則：
\startformula\startmathalignment
\NC h
   \NC\ge \lg(k!)^{n/k} \NR
\NC\NC=   (n/k)\lg(k!) \NR
\NC\NC\ge (n/k)(k/2)\lg(k/2) \qquad \text{（\refexercise{bound_of_lgnfrac}）}\NR
\NC\NC=   \frac{1}{2}n\lg{k} - \frac{1}{2}n \NR
\NC\NC=   \Omega(n\lg{k}) \NR
\stopmathalignment\stopformula
\stopANSWER

\stopsection

\startsection[
  title={Counting sort},
]

\startEXERCISE
參照圖 8-2 的方法，說明 \ALGO{COUNTING-SORT} 在數列 \m{A=\langle 6,0,2,0,1,3,4,6,1,3,2\rangle} 上的操作過程。
\stopEXERCISE

\startANSWER
\externalfigure[output/e8_2_1-1]
\externalfigure[output/e8_2_1-2]
\externalfigure[output/e8_2_1-3]
\externalfigure[output/e8_2_1-4]
\externalfigure[output/e8_2_1-5]
\externalfigure[output/e8_2_1-6]
\externalfigure[output/e8_2_1-7]
\externalfigure[output/e8_2_1-8]
\externalfigure[output/e8_2_1-9]
\externalfigure[output/e8_2_1-10]
\externalfigure[output/e8_2_1-11]
\externalfigure[output/e8_2_1-12]
\externalfigure[output/e8_2_1-13]
\stopANSWER

\startEXERCISE
試證明 \ALGO{COUNTING-SORT} 是穩定的。
\stopEXERCISE

\startANSWER
假定兩個下標爲 \m{i_1} 和 \m{i_2}，且 \m{i_1 < i_2} 的元素相等。
排序後位置爲 \m{j_1} 和 \m{j_2}。
由於 \ALGO{COUNTING-SORT} 是從右向左處理數列元素的，
會先處理 \m{A[i_2]}，將其放入 \m{B[j_2]} 中，
然後再處理 \m{A[i_1]}，將其放入 \m{B[j_1]} 中。
由算法可知 \m{j_2 > j_1}，因此算法是穩定的。
\stopANSWER

\startEXERCISE
假設我們在 \ALGO{COUNTING-SORT} 的第 10 行循環的開始部分，將代碼改爲：
\startCLRS[start=10]
for j = 1 to A.length
\stopCLRS
試證明該算法仍然是正確的。他還穩定嗎？
\stopEXERCISE

\startANSWER
算法仍然正確，但不穩定了。相等的元素會以相反的順序出現在排好序的數列中。
\stopANSWER

\startEXERCISE
設計一個算法，他能夠對於任何給定的介於 \m{0} 到 \m{k} 之間的 \m{n} 個整數先進行預處理，
然後在 \m{O(1)} 時間內回答輸入的 \m{n} 個整數中有多少個落在區間 \m{[a..b]} 內。
你設計的算法的預處理時間應爲 \m{\Theta(n+k)}。
\stopEXERCISE

\startANSWER
先利用 \ALGO{COUNTING-SORT} 中的部分代碼構建數列 \m{C}，即預處理，時間爲 \m{\Theta(n) + \Theta(k) = \Theta(n+k)}。
然後直接由 \m{C[b] - C[a-1]} 即可得到想要的結果，時間爲 \m{O(1)}。
\stopANSWER

\stopsection

\startsection[
  title={Radix sort},
]

\startEXERCISE
參照圖 8-3 的方法，說明 \ALGO{RADIX-SORT} 在下列英文單詞上的操作過程：
 COW、 DOG、 SEA、 RUG、 ROW、 MOB、 BOX、 TAB、 BAR、 EAR、 TAR、 DIG、 BIG、 TEA、 NOW、 FOX。
\stopEXERCISE

\startANSWER
\leavevmode
\externalfigure[output/e8_2_2-1]
\externalfigure[output/e8_2_2-2]
\externalfigure[output/e8_2_2-3]
\externalfigure[output/e8_2_2-4]
\stopANSWER

\startEXERCISE
下面的排序算法中哪些是穩定的：插入排序、歸並排序、堆排序和快速排序？
給出一個能使任何配序算法都穩定的方法。
你所給出的方法帶來的額外時間和空間開銷是多少？
\stopEXERCISE

\startANSWER
插入排序、歸並排序是穩定的； 堆排序和快速排序是不穩定的。

我們可以用額外空間存儲每個元素的索引，索引和元素本身一起移動，
比較時，先比較元素本身，如果元素本身相同，則比較索引，
這樣相當於保證所有元素互異，這樣無論用哪種排序算法都能保證穩定。
所需的額外空間爲 \m{\Theta(n)}。
所需的額外時間爲當於算法本身時間復雜度具有同樣的數量級。
\stopANSWER

\startEXERCISE
利用歸納法來證明基數排序是正確的。
在你所給出的證明中，
在哪裏需要假設所用的底層配序算法是穩定的？
\stopEXERCISE

\startANSWER
不變式：

{\EMP 在 for 循環開始，數列已經對最低 \m{i-1} 位排好序。}

{\EMP 初始化：}數列對最低的 0 位已經排好序；

{\EMP 保持：}假設數列已經對最低 \m{i-1} 位排好序，
在對第 \m{i} 位排序後，數列就對最低 \m{i} 位都排好序了。
顯然第 \m{i} 位本身的排序是沒問題的，問題是當第 \m{i} 位相同時，
由於排序算法是穩定的且最低 \m{i-1} 位已經排好序，所以最低 \m{i} 位均是排好序的。

{\EMP 終止：} \m{i=d+1} 時循環終止。根據不變式，所有 \m{d} 位都是排好序的。

在{\EMP 保持}時需要假設算法是穩定的。
\stopANSWER

\startEXERCISE
說明如何在 \m{O(n)} 時間內，對 0 到 \m{n^3-1} 區間內的 \m{n} 個整數進行排序。
\stopEXERCISE

\startANSWER
將數列元素以 \m{n} 進制表示，則有 3 位。
根據{\EMP 引理 8.3}，所需時間爲 \m{\Theta(d(n+k))=\Theta(3(n+n))=\Theta(6n)=\Theta(n)}。
\stopANSWER

\startEXERCISE\DIFFICULT
在本節給出的第一個卡片排序算法中，
爲排序 \m{d} 位十進制數，
在最壞情況下需要多少輪排序？
在最壞情況下，操作員需要記錄多少堆卡片？
\stopEXERCISE

\startANSWER
算法執行過程爲（以三進制爲例）：
\startCLRS
- 按第一位分組
  - 將第一位爲 0 的分組
    - 將第二位爲 0 的分組
      。。。
    - 將第二位爲 1 的分組
      。。。
    - 將第二位爲 2 的分組
      。。。
  - 將第一位爲 1 的分組
    。。。
  - 將第一位爲 2 的分組
    。。。
\stopCLRS

可以看出算法爲指數級的。需要時間爲 \m{\Theta(k^d)}。
空間則爲 \m{\Theta(nk)}。
\stopANSWER

\stopsection

\startsection[
  title={Bucket sort},
]

\startEXERCISE
參照圖 8-4 的方法，說明 \ALGO{BUCKET-SORT} 在數列 \m{A = \langle .79, .13, .16, .64,
.39, .20, .89, .53, .71, .42 \rangle} 上的操作過程。
\stopEXERCISE

\startANSWER
\externalfigure[output/e8_4_1-1]
\stopANSWER

\startEXERCISE
解釋爲什麼桶排序在最壞情況下運行時間是 \m{\Theta(n^2)}？
我們應該如何修改算法，使其在保持平均情況爲線性時間代價的同時，
最壞情況下時間代價爲 \m{O(n\lg{n})}？
\stopEXERCISE

\startANSWER
如果所有元素全部落在同一桶中，並且是逆序的，則需要對這個桶中的 \m{n} 個逆序元素進行插入排序，
時間爲 \m{\Theta(n^2)}。

我們可以用堆排序或歸並排序來代替插入排序，以減少最壞情況的運行時間。
之所以選擇插入排序，是因爲他可以在鏈表上很好的工作。
如果用其他算法，則可能需要將鏈表改稱數組，這可能會降低算法的速度。
\stopANSWER

\startEXERCISE
設 \m{X} 是一個隨機變量，用於表示在將一枚硬幣拋擲兩次時，正面朝上的次數。
 \m{E[X^2]} 是多少？ \m{E^2[X]} 是多少？
\stopEXERCISE

\startANSWER
\startformula
E[X] = 2 \cdot \frac{1}{4} + 1 \cdot \frac{1}{2} + 0 \cdot \frac{1}{4} = 1
\stopformula

\startformula
E[X^2] = E[X] \cdot E[X] = 1
\stopformula

\startformula
E^2[X] = E[X] \cdot E[X] = 1
\stopformula
\stopANSWER

\startEXERCISE\DIFFICULT
在單位圓內給定 \m{n} 個點， \m{p_i=(x_i,y_i)}，
對所有 \m{i=1,2,\ldots,n}，有 \m{0<x_i^2+y_i^2\le 1}。
假設所有點服從均勻分布，即在單位元的任一區域內找到給定點的概率與該區域的面積成正比。
請設計一個在平均情況下有 \m{\Theta(n)} 時間代價的算法，
他能夠按照點到原點之間的距離 \m{d_i=\sqrt{x_i^2+y_i^2}} 對這 \m{n} 個點進行排序。
\stopEXERCISE

\startANSWER
單位圓面積爲 \m{\pi 1^2=\pi}，將其 \m{n} 等分，每塊面積爲 \m{\pi/n}。
如果圓環的內徑爲 \m{a}，外徑爲 \m{b}，則其面積爲 \m{\pi(b^2-a^2)}。

選取半徑序列 \m{a_0,a_1,a_2,\ldots,a_n} 將單位圓劃分成面積相等的 \m{n} 等份。
第 \m{i} 個圓環內外徑分別爲 \m{a_{i-1}} 和 \m{a_i}。
已知 \m{a_0=0} 且 \m{a_n=1}。則：
\startformula\startmathalignment[n=1]
\NC \pi^2 \pi(a_i^2 - a_{i-1}^2) = \pi(a_j^2 - a_{j-1}^2) = \frac{\pi}{n} \NR
\NC \Downarrow \NR
\NC a_i^2 - a_{i-1}^2 = a_j^2 - a_{j-1}^2 = \frac{1}{n} \NR
\NC \Downarrow \NR
\NC a_i^2 = \frac{1}{n} + a_{i-1}^2 \NR
\stopmathalignment\stopformula
得到如下遞迴式：
\startformula\startmathalignment
\NC a_0 \NC= 0 \NR
\NC a_i \NC= \sqrt{1/n + a_{i-1}^2} \NR
\stopmathalignment\stopformula
解得：
\startformula
a_i=\frac{\sqrt{i}}{\sqrt{n}}
\stopformula

因此，桶的半徑區間爲：
\startformula
\left(0, \frac{1}{\sqrt n} \right],
   \left(\frac{1}{\sqrt n}, \frac{\sqrt 2}{\sqrt n}\right], \cdots,
   \left(\frac{\sqrt{n-1}}{\sqrt n}, 1 \right]
\stopformula

半徑爲 \m{d} 的元素應該放入第 \m{k} 個桶中（從 1 開始計數）， \m{k} 爲：
\startformula
k = \left\lceil d^2n \right\rceil
\stopformula
\stopANSWER

\startEXERCISE\DIFFICULT
定義隨機變量 \m{X} 的{\EMP 概率分布函數} \m{P(x)} 爲 \m{P(x)=\Pr\{X\le x\}}。
假設有 \m{n} 個隨機變量 \m{X_1,X_2,\ldots,X_n} 服從一個連續概率分布函數 \m{P}，
且他可以在 \m{O(1)} 時間內被計算得到。
設計一個算法，使其能在平均情況下以線性時間對這些數進行排序。
\stopEXERCISE

\startANSWER
與上一練習類似，關鍵在於如何構造“桶”。
\stopANSWER

\stopsection

\startsubject[
  title={Problems},
]

\startPROBLEM
（Probabilistic lower bounds on comparison sorting）
在這一問題中，我們將證明對於給定的 \m{n} 個互異的輸入元素，
任何確定或隨機的排序比較算法，其概率運行時間都有下界 \m{\Omega(n\lg{n})}。
首先來分析一個確定的比較排序算法 \m{A}，其決策樹爲 \m{T_A}。
假設 \m{A} 的輸入的所有排列情況可能性相同。
\startigBase[a]
\startitem
假設 \m{T_A} 的每個葉子節點都標有在給定的隨機輸入情況下到達該節點的概率。
證明：恰有 \m{n!} 個葉子節點標有 \m{1/n!}，其他的葉子節點標記爲 \m{0}。
\stopitem

\startANSWER
有 \m{n!} 種排序結果，每一種都對應 \m{n!} 種輸入中的一種。
每種排序結果都對應一個葉子節點，由於各種輸入的可能性相同，
到達具體排序結果的概率均爲 \m{1/n!}。
除了這 \m{n!} 種結果所對應的葉子節點，即使決策樹有其他有更多葉子節點，也無法到達。

當然以上僅憑直覺，正式的證明卻有點麻煩。
\stopANSWER

\startitem
定義 \m{D(T)} 表示一顆決策樹 \m{T} 的外部路徑長度，
即 \m{D(T)} 是 \m{T} 的所有葉子節點深度的和。
假設 \m{T} 爲一顆有 \m{k>1} 個葉子節點的決策樹，
 \m{LT} 和 \m{RT} 分別是 \m{T} 的左子樹和右子樹。
證明：
\startformula
\m{D(T) = D(LT) + D(RT) + k}。
\stopformula
\stopitem

\startANSWER
而子樹上的葉子節點在原樹上也是葉子節點。
原樹上的葉子節點也是子樹上的葉子節點（不是左子樹的葉子，就是右子樹的葉子）。
因此 \m{LEAVES(LT) + LEAVES(RT) = k}。
對於子樹上的每個葉子節點而言，在子樹上的深度比在原樹上的深度小 1。
因此：
\startformula
\m{D(T) = D(LT) + LEAVES(LT) + D(RT) + LEAVES(RT) = D(LT) + D(RT) + k}
\stopformula
\stopANSWER

\startitem
定義 \m{d(k)} 爲所有具有 \m{k>1} 個葉子節點的決策樹 \m{T} 的最小 \m{D(T)} 值。
證明：
\startformula
d(k) = \min_{1\le i\le {k-1}}\left\{d(i)+d(k-i)+k\right\}
\stopformula
（\hint 慮一顆能夠取得最小值的、有 \m{k} 個葉子節點的決策樹 \m{T}。
設 \m{i_0} 是 \m{LT} 中的葉子節點數， \m{k-i_0} 是 \m{RT} 中的葉子節點數。）
\stopitem

\startANSWER
對於一顆具有 \m{k} 個葉子節點的決策樹，由上一項可知 \m{D(T) = D(LT) + D(RT) + k}。
而左子樹上葉子節點有從 \m{1} 到 \m{k-1} 共 \m{k-1} 種可能。
由 \m{d(k)} 的定義即得所要證明的結論。
\stopANSWER

\startitem
證明： \m{d} 對於給定的 \m{k} 和 \m{i} （\m{k>1} 且 \m{1\le i\le {k-1}}），
函數 \m{i\lg{i}+(k-i)\lg{k-i}} 在 \m{i=k/2} 處取得最小值，
並有結論 \m{d(k)=\Omega(k\lg{k})}。
\stopitem

\startANSWER
\startformula\startmathalignment
\NC f(i) \NC= i\lg{i} + (k-i)\lg(k-i) \NR
\NC f'(i) \NC= \lg{i} + 1 - \lg(k-i) - 1 = \lg\frac{i}{k-i} \NR
\NC f'(i) = 0 \NC \Leftrightarrow \lg\frac{i}{k-i} = 0 \Rightarrow i/(k-i) = 1 \Rightarrow i = \frac k 2 \NR
\stopmathalignment\stopformula

由於 \m{f'(i)} 單調遞增，因此 \m{f(i)} 在 \m{i=k/2} 處取得局部最小值。

就直覺而言，應該是左右兩顆子樹大小相同時取得最小值。
\stopANSWER

\startitem
證明： \m{D(T_A)=\Omega(n!\lg(n!))}，且在平均情況下，
對 \m{n} 個元素進行排序的時間代價爲 \m{\Omega(n\lg{n})}。
\stopitem

\startANSWER
在 \m{T_A} 上有 \m{n!} 個葉子節點，
由上一項可知 \m{D(n)>d(k)=\Omega(n!\lg(n!))}。
每種排列的概率都是 \m{1/n!}，
因此排序的期望時間爲：
\startformula
\frac{\Omega(n!\lg(n!))}{n!} = \Omega(\lg(n!)) = \Omega(n\lg{n})
\stopformula
\stopANSWER
\stopigBase

現在考慮一個隨機化的比較排序 \m{B}。
通過引入兩種節點，
我們可以將決策樹模型擴展來處理隨機化的情況。
這兩種節點是：
普通哦年個的比較節點和“隨機化”節點。
隨機化節點刻劃了算法 \m{B} 種所做的形如 \ALGO{RANDOM(1, r)} 的隨機選擇情況。
該類節點有 \m{r} 個子節點，
在算法執行過程中，每一個子節點等概率地被選擇。
\startigBase[a,continue]
\startitem
證明：對任何隨機化比較排序算法 \m{B}，
總存在一個確定的比較排序算法 \m{A}，
其期望的比較次數不多於 \m{B} 的比較次數。
\stopitem

\startANSWER
隨機算法 \m{B} 所對應的確定算法 \m{A} 可以認爲只是進行了預先的“隨機”選擇。
我們可以通過將隨機節點替換爲我們所選的一個子節點，來構造確定算法的決策樹。
隨機節點的所有子樹的期望值要大於等於其中最小的那棵子樹。
由於確定算法時間代價爲 \m{\Omega(n\lg{n})}，
因此隨機算法的時間代價亦爲 \m{\Omega(n\lg{n})}。
\stopANSWER
\stopigBase

\stopPROBLEM

\startPROBLEM
（Sorting in place in linear time）
假設有一個包含 \m{n} 個待排序數據記錄的數列，
且每條記錄的關鍵字值爲 \m{0} 或 \m{1}。
對這樣一組記錄進行排序的算法可能具備如下三中特性中的一部分：
\startigBase[n]
\item 算法的時間代價是 \m{O(n)}；
\item 算法是穩定的；
\item 算法是原址排序，除了輸入數列之外，算法只需要固定的額外存儲空間。
\stopigBase

\startigBase[a]
\startitem
給出一個滿足上述條件 1 和條件 2 的算法。
\stopitem

\startANSWER
計數排序。
\stopANSWER

\startitem
給出一個滿足上述條件 1 和條件 3 的算法。
\stopitem

\startANSWER
改造計數排序，不求穩定，即可做到原址排序。
\stopANSWER

\startitem
給出一個滿足上述條件 2 和條件 3 的算法。
\stopitem

\startANSWER
冒泡排序。
\stopANSWER

\startitem
你設計的上面三個算法中是否可也將其中一個用於 \ALGO{RADIX-SORT} 的第 2 行作爲基礎排序方法，
從而使 \ALGO{RADIX-SORT} 在排序有 \m{b} 位關鍵字的 \m{n} 條記錄時的時間代價位 \m{O(bn)}？
如果可以，請解時應如何處理；如果不行，請說明原因。
\stopitem

\startANSWER
只有第一項的計數排序可以。基數排序要求穩定，另外基礎排序要求時間代價爲 \m{\Theta(n)}。
\stopANSWER

\startitem
假設有 \m{n} 條記錄，其中所有關鍵字的值都在 \m{1} 到 \m{k} 的區間內。
你應該如何修改計數排序，
使得他可以在 \m{O(n+k)} 的時間內完成對 \m{n} 條記錄的原址排序。
除輸入數列外，
你可以使用 \m{O(k)} 大小的額外存儲空間。
你給出的算法是穩定的嗎？
（\hint \m{k=3} 時，你應該如何做？）
\stopitem

\startANSWER
\startCLRS
for i = 0 upto range
	cnt[i] = counts[i]
while i ≤ A.length
	key = A[i]
	if cnt[key - 1] < i and cnt[key] <= i
		++i
	else
		exchange A[i] with A[counts[key]]
		--counts[key]
\stopCLRS
\stopANSWER
\stopigBase
\stopPROBLEM

\startPROBLEM
（Sorting variable-length items）
\startigBase[a]
\startitem
給定一個整數數列，其中不同的整數所包含的數字的位數可能不同，
但該數列中，所有整數中包含的總數字位數爲 \m{n}。
設計一個算法，使其可以在 \m{O(n)} 時間內對該數列進行排序。
\stopitem

\startANSWER
先將元素按數字位數分組，然後在組內進行基數排序。
令 \m{G_i} 表示具有 \m{i} 位的元素集合，令 \m{c_i=\left|G_i\right|}，則：
\startformula
T(n) = \sum_{i=1}^{n}c_i\cdot i = n
\stopformula
\stopANSWER

\startitem
給定一個字串數列，其中不同的字串所包含的字符數可能不同，
但所有字串中的總字符數爲 \m{n}。
設計一個算法，使其可以在 \m{O(n)} 時間內對該數列進行排序。
（{\EMP 注意：}此處的順序是指標準的字典序，例如 \m{a<ab<b}。）
\stopitem

\startANSWER
根據上一項的分析撰寫算法。
\stopANSWER
\stopigBase
\stopPROBLEM

\startPROBLEM
（Water jugs）
假設給了你 \m{n} 個紅色的水壺和 \m{n} 個藍色的水壺。
他們的形狀和尺寸都各不相同。
所有的紅色水壺中所盛的水都不一樣多，
藍色水壺亦是如此。
而且，對於每一個紅色水壺來說，
都有一個對應的藍色水壺，兩者盛有一樣多的水；反之亦然。

你的任務是找出所有的所盛水量一樣多的紅色水壺和藍色水壺，並將他們配成一對。
爲此，可以執行如下操作：
挑出一對水壺，其中一個是紅色的，一個是藍色的，
將紅色水壺中倒滿水，再將水倒入藍色的水壺中。
通過這一操作，可以判斷出這個紅色水壺是否比藍色水壺盛的水更多，或者兩者是一樣多的。
假設這樣的比較需要花費一個單位時間。
你的目標是找出一個算法，他能夠用最少的比較次數來確定所有水壺的配對。
注意，你不能直接比較兩個紅色或兩個藍色的水壺。

\startigBase[a]
\startitem
設計一個確定性算法，能用 \m{\Theta(n^2)} 次比較來完成所有水壺的配對。
\stopitem

\startANSWER
任取一紅色水壺，將其與所有藍色水壺比較，直至找到與之配對的藍色水壺。
待爲所有紅色水壺都找到了與之配對的藍色水壺，算法終止。
\stopANSWER

\startitem
證明：解決該問題算法的比較次數下界爲 \m{\Omega(n\lg{n})}。
\stopitem

\startANSWER
参考\refsection{lower_bound_sorting}。
只是决策树上的每个节点有三个子节点，即是{\EMP 三叉树}。
如果两种水壶各自都是有序的，则一种配对即一个 \m{n} 项排列，将红蓝水壶进行映射。
由于有 \m{n!} 种结果，每种结果都是决策树中的一个叶子节点。
假如树中共有 \m{l} 个节点：
\startformula
n! \le l \le 3^h
\stopformula
则：
\startformula
h \ge \lg(n!) = \Omega(n\lg{n})
\stopformula
\stopANSWER

\startitem
設計一個隨機演算法，其期望的比較次數為 \m{O(n\lg{n})}，
並證明這個界是正確的。
對你的演算法而言，最壞情況下的比較次數是多少？
\stopitem

\startANSWER
可以時用與快速配序類似的方式。以如下步驟進行劃分：
\startigBase[n]
\item 隨機選擇一個紅色水壺作為紅色主元；\m{O(1)}
\item 選擇紅色主元所對應的藍色水壺作為藍色主元；\m{O(n)}
\item 以紅色主元劃分藍色水壺，並將藍色主元歸位；\m{O(n)}
\item 以藍色主元劃分紅色水壺，並將紅色主元歸位。\m{O(n)}
\stopigBase

只在紅藍水壺間進行比較。
\stopANSWER
\stopigBase
\stopPROBLEM

\startPROBLEM
（Average sorting）
假設我們不需要完全排序一個數列，
而值是要求數列中的元素在平均情況下是升序的。
更準確地說，如果對所有的 \m{i=1,2,\ldots,n-k} 有下式成立，
我們就稱一個包含 \m{n} 個元素的數列 \m{A} 是 {\EMP \m{k} 排序}（\m{k}-sorted）的：
\startformula
\frac{\sum_{j=i}^{i+k-1}A[j]}{k} \le \frac{\sum_{j=i + 1}^{i+k}A[j]}{k}
\stopformula

\startigBase[a]
\startitem
一個數列是 1 排序的，表示什麼含義？
\stopitem

\startANSWER
將 \m{k=1} 代入可得： \m{A[j] \le A[j+1]}，其中 \m{1 \le j \le n-1}。即整個數列是完全升序的。
\stopANSWER

\startitem
給出對數字 \m{1,2,\ldots,10} 的一個排列，他是 2 排序的，但不是完全有序的。
\stopitem

\startANSWER
\m{2, 1, 4, 3, 6, 5, 8, 7, 10, 9}。
\stopANSWER

\startitem
證明：一個包含 \m{n} 個元素的數列是 \m{k} 排序的，
當且僅當對所有 \m{i=1,2,\ldots,n-k}，有 \m{A[i]\le A[i+k]}。
\stopitem

\startANSWER
\startformula\startmathalignment[n=1]
\NC \frac{\sum_{j=i}^{i+k-1}A[j]}{k} \le \frac{\sum_{j=i + 1}^{i+k}A[j]}{k} \NR
\NC \Updownarrow \NR
\NC \frac{A[i] + \sum_{j=i+1}^{i+k-1}A[j]}{k} \le
     \frac{\sum_{j=i+1}^{i+k-1}A[j] + A[i+k]}{k} \NR
\NC \Updownarrow \NR
\NC \frac{A[i]}{k} \le \frac{A[i+k]}{k} \NR
\NC \Updownarrow \NR
\NC A[i] \le A[i+k] \NR
\stopmathalignment\stopformula
\stopANSWER

\startitem
設計一個算法，他能在 \m{O(n\lg(n/k))} 時間內對一個包含 \m{n} 個元素的數列進行 \m{k} 排序。
\stopitem

\startANSWER
將數列劃分成 \m{k} 個子數列，記爲 \m{A_s}，其中 \m{s=1,2,\ldots,k}。

而 \m{A_s[i] = A[s + i \times k]}，其中 \m{i=0,1,2,\ldots,n/k-1}。

只需將這 \m{k} 個子數列排序即可。每個子數列元素個數爲 \m{n/k}，
總時間爲 \m{O((n/k)\lg(n/k)) \times k = O(n\lg(n/k))}。
\stopANSWER
\stopigBase

當 \m{k} 是一個常數時，也可以給出 \m{k} 排序算法的下界。
\startigBase[a,continue]
\startitem
證明：我們可以在 \m{O(n\lg{k})} 時間內對一個長度爲 \m{n} 的 \m{k} 排序數列進行全排序。
\hint 以利用\refexercise{k_merge} 的結果。）
\stopitem

\startANSWER
即總元素個樹爲 \m{n} 的 \m{k} 個有序數列，進行歸並排序，參見\refexercise{k_merge}。
\stopANSWER

\startitem
證明：當 \m{k} 是一個常數時，對包含 \m{n} 個元素的數列進行 \m{k} 排序需要 \m{\Omega(n\lg{n})} 的時間。
（\hint 以利用千米解決比較排序的下界的方法。）
\stopitem

\startANSWER
還是解決 \m{k} 個規模爲 \m{n/k} 的子問題，每個子問題最少比較次數爲 \m{\Omega((n/k)\lg(n/k))}，
總共 \m{\Omega(n\lg(n/k))}。
\stopANSWER
\stopigBase
\stopPROBLEM

\startPROBLEM
（Lower bound on merging sorted lists）
我們經常遇到合並兩個有序列表的問題。
作爲 \ALGO{MERGE-SORT} 的子過程，
我們在節 2.3.1 中已經遇到過這一問題。
對這一問題，我們將證明在最壞情況下，
合並兩個都包含 \m{n} 個元素的有序列表所需的比較次數下界爲 \m{2n-1}。

首先，利用決策樹來說明比較次數有一個下界 \m{2n-o(n)}。

\startigBase[a]
\startitem
給定 \m{2n} 個數，請算出共有多少種可能的方式將他們劃分成兩個有序列表，
其中每個列表都包含 \m{n} 個數。
\stopitem

\startANSWER
\startformula
\binom{2n}{n}
\stopformula
\stopANSWER

\startitem
利用決策樹和上一項的結果，正面：
任何能夠正確合併兩個有序列表的算法都至少要進行 \m{2n-o(n)} 次比較。
\stopitem

\startANSWER
由\refexercise{c_2n_n} 可知：
\startformula
\binom{2n}{n} = \frac{2^{2n}}{\sqrt{\pi n}}(1 + \O(1/n))
\stopformula

如果決策樹中有 \m{l} 個葉子節點，且高度爲 \m{h}，則：
\startformula
\frac{2^{2n}}{\sqrt{\pi n}}(1 + \O(1/n)) \le l \le 2^h
\stopformula

不等式兩端取對數：
\startformula\startmathalignment
\NC h \NC \ge \lg\left(\frac{2^{2n}}{\sqrt{\pi n}}(1 + \O(1/n))\right) \NR
\NC   \NC = \lg{2^{2n}} - \lg\sqrt{\pi n} + \lg(1 + O(1/n)) \NR
\NC   \NC = 2n - \o(n) \NR
\stopmathalignment\stopformula
\stopANSWER
\stopigBase

現在我們給出一個更緊確的界 \m{2n-1}。
\startigBase[a,continue]
\startitem
請說明：如果兩個元素在有序序列中是連續的，且分別來自不同的列表，則他們必須進行比較。
\stopitem

\startANSWER
如果不進行比較，我們不知道這兩個元素誰先誰後。
當然如果這兩個元素來自同一個列表，則無需比較。
\stopANSWER

\startitem
利用上一項的結論，說明合併兩個有序列表時的比較次數下界爲 \m{2n-1}。
\stopitem

\startANSWER
如果兩個有序列表 \m{\langle a_1,a_2,\ldots,a_n\rangle} 和 \m{\langle b_1,b_2,\ldots,b_n} 合併後
爲 \m{\langle a_1,b_1,a_2,b_2,\ldots,a_n,b_n}，
則任意相鄰兩個元素均須比較，共需比較次數爲 \m{2n-1}。
這是最壞情況。
\stopANSWER
\stopigBase
\stopPROBLEM

\startPROBLEM
（The 0-1 sorting lemma and columnsort）
對兩個數列元素 \m{A[i]} 和 \m{A[j]} （其中 \m{i < j}）進行{\EMP 比較交換}（{\EMP compare-exchange}）的形式如下：

\CLRSH{COMPARE-EXCHANGE(A, i, j)}
\startCLRS
if A[i] > A[j]
	exchange A[i] with A[j]
\stopCLRS

比較交換後，則 \m{A[i] \le A[j]}。

{\EMP 遺忘比較交換算法（oblivious compare-exchange algorithm）}指算法只按照事先
定義好的操作執行，
即需要比較的位置下標必須事先確定好。
雖然算法可能依靠待排序元素個數，但他不能依賴待排序元素的值，
也不能依賴任何之前的比較交換操作的結果。
例如，下面是一個基於遺忘比較交換算法的插入排序：

\CLRSH{INSERTION-SORT(A)}
\startCLRS
for j = 2 to A.length
	for i = j - 1 downto 1
		COMPARE-EXCHANGE(A, i, i + 1)
\stopCLRS

{\EMP 0-1 排序引理（0-1 sorting lemma）}提供了有力的方法來證明
一個遺忘比較交換算法可以產生正確的排序結果。
該引理表明，如果一個遺忘比較交換算法能夠對所有只包含 0 和 1 的輸入序列排序，
那麼他就可以對包含任意值的輸入序列排序。

你可以用反例來證明 0-1 排序引理：
如果一個遺忘比較交換算法不能對一個包含任意值的序列進行排序，
那麼他也不能對某個 0-1 序列進行排序。
不妨假設一個遺忘比較交換算法 \m{X} 未能對數列 \m{A[1..n]} 排序。
設 \m{A[p]} 是算法 \m{X} 未能將其放到正確位置上的最小元素，
而 \m{A[q]} 是被算法 \m{X} 放在 \m{A[p]} 原本應該所在位置上的元素。
定義一個只包含 0 和 1 的數列 \m{B[1..n]} 如下：
\startformula
B[i] = \startmathcases
\NC 0	\MC \text{若 \m{A[i]\le A[p]}，} \NR
\NC 1	\MC \text{若 \m{A[i] > A[p]}。} \NR
\stopmathcases
\stopformula

\startigBase[a]
\startitem
討論：當 \m{A[q]>A[p]} 時，有 \m{B[p]=0} 和 \m{B[q]=1}。
\stopitem

\startANSWER
\m{A[p]} 和 \m{A[q]} 所放位置均不正確，且 \m{A[p]} 是位置不正確的最小元素，
因此 \m{A[q] > A[p]}。將 \m{i=p,q} 代入即得 \m{B[p]=0} 和 \m{B[q]=1}。
\stopANSWER

\startitem
爲完成 0-1 排序引理的正面，請先證明算法 \m{X} 不能對數列 \m{B} 正確排序。
\stopitem

\startANSWER
參見 \goto{0-1 排序引理的證明}[url(http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/networks/nulleinsen.htm)]。
\stopANSWER
\stopigBase

現在，需要用 0-1 排序引理來正面一個特別的排序算法的正確性。
{\EMP 列排序}算法用於包含 \m{n} 個元素的矩形數列的排序。
這一矩形數列有 \m{r} 行 \m{s} 列（因此 \m{n=rs}），
滿足下列三個限制條件：
\startigBase[2][indentnext=no]
\item \m{r} 必須是偶數；
\item \m{s} 必須是 \m{r} 的因子；
\item \m{r\ge 2s^2}；
\stopigBase
當排序完成時，矩形數列是{\EMP 列優先有序}的：
按照列從上到下，從左到右，都是單調遞增的。

如果不包括 \m{n} 的值的計算，列排序需要 8 步操作。
所有奇數步都一樣：對每一列單獨進行排序。
每一個偶數步是一個特定的排列。具體如下：
\startigNum[n]
\item 對每一列進行排序；
\item 將矩形數列轉置，並重新規整化爲 \m{r} 行 \m{s} 列的形式。
也就是說，首先將最左邊的一列放在前 \m{r/s} 行，
然後將下一列放在第二個 \m{r/s} 行，以此類推；
\item 對每一列進行排序；
\item 執行第 2 步排列操作的逆操作；
\item 對每一列進行排序；
\item 將每一列的上半部分移到同一列的下半部分位置，
將每一列的下半部分移到下一列的上半部分，
並將最左邊一列的上半部分置空。
此時，最後一列的下半部分成爲新的最右列的上半部分，新的最右列的下半部分爲空；
\item 對每一列進行排序；
\item 執行第 6 步排列操作的逆操作。
\stopigNum

下面爲對一個 \m{r=6,s=3} 的輸入矩形數列的排序過程（即使違背了 \m{r\ge 2s^2} 的條件，算法仍然有效）。
\startformula\startmatrix
\NC 10 \NC 14 \NC  5 \NR
\NC  8 \NC  7 \NC 17 \NR
\NC 12 \NC  1 \NC  6 \NR
\NC 16 \NC  9 \NC 11 \NR
\NC  4 \NC 15 \NC  2 \NR
\NC 18 \NC  3 \NC 13 \NR
\stopmatrix\stopformula

\startformula\startmatrix
\NC  4 \NC  1 \NC  2 \NR
\NC  8 \NC  3 \NC  5 \NR
\NC 10 \NC  7 \NC  6 \NR
\NC 12 \NC  9 \NC 11 \NR
\NC 16 \NC 14 \NC 13 \NR
\NC 18 \NC 15 \NC 17 \NR
\stopmatrix\stopformula

\startformula\startmatrix
\NC  4 \NC  8 \NC 10 \NR
\NC 12 \NC 16 \NC 18 \NR
\NC  1 \NC  3 \NC  7 \NR
\NC  9 \NC 14 \NC 15 \NR
\NC  2 \NC  5 \NC  6 \NR
\NC 11 \NC 13 \NC 17 \NR
\stopmatrix\stopformula

\startformula\startmatrix
\NC  1 \NC  3 \NC  6 \NR
\NC  2 \NC  5 \NC  7 \NR
\NC  4 \NC  8 \NC 10 \NR
\NC  9 \NC 13 \NC 15 \NR
\NC 11 \NC 14 \NC 17 \NR
\NC 12 \NC 16 \NC 18 \NR
\stopmatrix\stopformula

\startformula\startmatrix
\NC  1 \NC  4 \NC 11 \NR
\NC  3 \NC  8 \NC 14 \NR
\NC  6 \NC 10 \NC 17 \NR
\NC  2 \NC  9 \NC 12 \NR
\NC  5 \NC 13 \NC 16 \NR
\NC  7 \NC 15 \NC 18 \NR
\stopmatrix\stopformula

\startformula\startmatrix
\NC  1 \NC  4 \NC 11 \NR
\NC  2 \NC  8 \NC 12 \NR
\NC  3 \NC  9 \NC 14 \NR
\NC  5 \NC 10 \NC 16 \NR
\NC  6 \NC 13 \NC 17 \NR
\NC  7 \NC 15 \NC 18 \NR
\stopmatrix\stopformula

\startformula\startmatrix
\NC    \NC  5 \NC 10 \NC 16 \NR
\NC    \NC  6 \NC 13 \NC 17 \NR
\NC    \NC  7 \NC 15 \NC 18 \NR
\NC  1 \NC  4 \NC 11 \NC    \NR
\NC  2 \NC  8 \NC 12 \NC    \NR
\NC  3 \NC  9 \NC 14 \NC    \NR
\stopmatrix\stopformula

\startformula\startmatrix
\NC    \NC  4 \NC 10 \NC 16 \NR
\NC    \NC  5 \NC 11 \NC 17 \NR
\NC    \NC  6 \NC 12 \NC 18 \NR
\NC  1 \NC  7 \NC 13 \NC    \NR
\NC  2 \NC  8 \NC 14 \NC    \NR
\NC  3 \NC  9 \NC 15 \NC    \NR
\stopmatrix\stopformula

\startformula\startmatrix
\NC  1 \NC  7 \NC 13 \NR
\NC  2 \NC  8 \NC 14 \NR
\NC  3 \NC  9 \NC 15 \NR
\NC  4 \NC 10 \NC 16 \NR
\NC  5 \NC 11 \NC 17 \NR
\NC  6 \NC 12 \NC 18 \NR
\stopmatrix\stopformula

\startigBase[a,continue]
\startitem
討論：即使不知道奇數步採用了什麼排序算法，
我們也可以把列排序看作一種遺忘比較交換算法。
\stopitem
\stopigBase

雖然似乎很難讓人相信列排序也能實現排序，
但是你可以利用 0-1 排序引理來證明這一點。
因爲列排序可以看作是一種遺忘比較交換算法，
所以我們可以使用 0-1 排序引理。
下面一些定義有助於倪試用這一引理。
如果數列仲的某個區域只包含全 0 或者全 1,
我們定義這個區域是{\EMP 乾淨}的。
否則稱這個區域是{\EMP 髒}的。
這裏，假設輸入數據只包含 0 和 1，
且輸入數據能轉換成 \m{r} 行 \m{s} 列。
\startigBase[a,continue]
\startitem
證明：經過第 1～3 布，數列由三部分組成：
頂部一些由全 0 組成的乾淨行，底部一些由全 1 組成的乾淨行，
以及中間最多 \m{s} 行髒的行。
\stopitem

\startANSWER
第一步後，每一列均爲連續 0 後緊跟連續 1，只有一處 0 到 1 的跳變。
由於 \m{s} 整除 \m{r}，第二步會將第一步的每一列轉換爲 \m{r/s} 行。
在這 \m{r/s} 行中最多只有一行有 0 到 1 的跳變，其他行都是 0 或者都是 1。
即每一列所轉換的行中最多有一行是髒的。

第三步會將所有 0 行上移，所有 1 行下移，即最多只會剩下 \m{s} 行髒的行。
\stopANSWER

\startitem
證明：經過第 4 步後，如果按照列有限原則讀取數列，
先讀到的是全 0 的乾淨區域，最後是全 1 的乾淨區域，
中間是由最多 \m{s^2} 個元素組成的髒區域。
\stopitem

\startANSWER
第 4 步後按列優先讀數據，相當於在第 3 步後按行優先讀數據，參考上一項的證明，結論是顯然的。
\stopANSWER

\startitem
證明：第 5～8 步產生一個全排序的 0-1 輸出，
並得到結論：列排序可以正確地對任意輸入值排序。
\stopitem

\startANSWER
第四步後， 髒序列中最多有 \m{s^2} 個元素，爲一列元素的一半，
可能在一列中，也可能分散於相鄰兩列中。左邊的左右列爲 0，右邊的所有列爲 1。
如果髒序列在同一列中，則第 5 步即可保證每列有序，後續步驟不受影響。
如果髒序列分散於相鄰兩列中，則第 6 步會將髒序列轉移到同一列中。
\stopANSWER

\startitem
現在假設 \m{s} 不能被 \m{r} 整除。
證明：經過第 1～3 步，數列的頂部有一些全 0 的乾淨行，
底部有一些全 1 的乾淨行，中間最多 \m{2s-1} 行髒行。
那麼與 \m{s} 相比，在 \m{s} 不能被 \m{r} 整除時， \m{r} 至少要多大才能保證配序的正確性？
\stopitem

\startANSWER
如果 \m{s} 不能整除 \m{r}，一行可能不僅包含 0 到 1 的跳變，也包含 1 到 0 的跳變。
最多有 \m{s - 1}  行，即最多有 \m{2s-1} 個髒區域。
 \m{r} 至少要是 \m{2(2s-1)^2}。
\stopANSWER

\startitem
對第 1 步做一個簡單修改，使得我們可以在 \m{s} 不能被 \m{r} 整除時，也保證 \m{r\ge 2s^2}，
並且證明在這一修改後，列排序仍然正確。
\stopitem

\startANSWER
第一步中，可以用 \m{+\infty} 補齊數列使得 \m{s} 可以整除 \m{r}，
或者可以將數列截斷一小部分，對其獨立排序。後者會更有效，因爲無需移動數列。
其實這些均無必要，列排序對是否整除沒有嚴格要求，
細節參見\goto{這篇論文}[url(http://www.cs.dartmouth.edu/reports/TR2003-444.pdf)]。
\stopANSWER
\stopigBase

\stopPROBLEM

\stopsubject

\stopchapter
\stopcomponent
